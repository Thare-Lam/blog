<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thare</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thare.cn/"/>
  <updated>2019-04-02T07:27:55.246Z</updated>
  <id>https://thare.cn/</id>
  
  <author>
    <name>Thare_Lam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>商品ES索引同步历程</title>
    <link href="https://thare.cn/posts/23fc8314.html"/>
    <id>https://thare.cn/posts/23fc8314.html</id>
    <published>2019-03-29T16:58:57.000Z</published>
    <updated>2019-04-02T07:27:55.246Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Apr 02 2019 15:28:57 GMT+0800 (China Standard Time) --><p>最近对商品es同步应用（item-dump）做了些优化，感觉已经到了比较稳定成熟的阶段（啪啪），决定对整个商品es同步方案历程做个总结，希望能对其它同学在做es同步上提供参考。</p><a id="more"></a><p>商品索引在我们公司应该算是最复杂的索引，非常具有代表性：</p><ul><li>数据量大（目前2500w+，日增商品数高达10w）</li><li>实时性要求高（使用es搜索取代了一些慢sql，相当于把es当db来用）</li><li>业务场景复杂，目前共有5套商品索引</li><li>需要聚合非常多的业务信息，且聚合过程中需要做一些逻辑处理</li><li>更新频率高</li></ul><p>下面会通过几个方面来讲讲我在商品es同步中做的一些改进。</p><p>欢迎提出宝贵（吐）建（槽）议。</p><h2 id="应用独立性"><a href="#应用独立性" class="headerlink" title="应用独立性"></a>应用独立性</h2><h3 id="非独立"><a href="#非独立" class="headerlink" title="非独立"></a>非独立</h3><p>最开始商品es同步的代码是与商品业务代码存在于同一项目，部署在同一jvm中。在初期这种方案可以节约开发时间和精力，但会带来以下问题：</p><ul><li>与业务相互影响<ul><li>影响业务：es同步需要长时间调用大量接口且占用CPU从而影响正常业务请求。</li><li>被业务影响：业务原因造成宕机导致同步失败。</li></ul></li><li>发版不独立。es同步代码和部分业务代码分属不同团队，项目发版需要协调几个团队。且如果一方的代码需要回滚，又要做分支的处理重新发版，非常痛苦。</li></ul><h3 id="独立"><a href="#独立" class="headerlink" title="独立"></a>独立</h3><p>与业务应用独立，互不影响。</p><h2 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h2><p>当在一个新环境部署时，需要先执行全量同步。</p><h3 id="单机任务"><a href="#单机任务" class="headerlink" title="单机任务"></a>单机任务</h3><p>在一个JVM中获取全量的商品信息并同步至es中。这种方案有如下缺点：</p><ul><li>不能利用集群优势加快任务处理速度。</li><li>不支持恢复。如果在任务执行过程中应用宕机，那么整个任务都要重新开始。</li><li>如果要停止任务，需要重启应用。</li></ul><h3 id="MQ分布式任务"><a href="#MQ分布式任务" class="headerlink" title="MQ分布式任务"></a>MQ分布式任务</h3><p>将商品id发送到mq中，消费者消费消息即可。这种方案有如下优点：</p><ul><li>利用集群优势分布式处理，降低任务总耗时。</li><li>可以通过调整mq消费者线程数来调整任务的处理速度。</li><li>支持恢复。当应用在全量同步任务过程中发生宕机，重启后继续消费消息即可。</li><li>停止同步任务只需重置mq消费位点。</li></ul><h2 id="商品ID获取"><a href="#商品ID获取" class="headerlink" title="商品ID获取"></a>商品ID获取</h2><p>全量同步方法的入参是商品id，因此需要获取到所有的商品id。</p><h3 id="遍历商品表"><a href="#遍历商品表" class="headerlink" title="遍历商品表"></a>遍历商品表</h3><p>遍历商品表获取到所有的商品id，这种方法比较耗时（遍历全表）。且如果在中途查询db失败，那么需要重新开始获取所有id。</p><h3 id="取id从1取至max"><a href="#取id从1取至max" class="headerlink" title="取id从1取至max"></a>取id从1取至max</h3><p>由于商品表id是连续递增的，可以先获取到maxId，然后从1到maxId遍历发送消息。这样几秒钟就能发送完所有消息，同时又能减少db查询。</p><h3 id="使用redis存储id"><a href="#使用redis存储id" class="headerlink" title="使用redis存储id"></a>使用redis存储id</h3><p>商品表接入drds（分库分表）后，商品id不再是连续递增的，中间会存在很大的间隔。这种情况下，再通过从1到maxId遍历发送消息会导致消费方接收到很多不存在的id，从而造成很多的无用接口调用。</p><p>使用redis存储商品id：</p><ul><li>冷启动需要初始化，遍历所有表获取全量的商品id（只需执行一次）</li><li>对商品表做canal监听，有新商品产生则把id存入redis</li></ul><blockquote><p>商品drds是通过id做路由的，通过ids查询时如果ids存在于不同表实例中，会对不同表做查询最后再汇总。为了节约汇总耗时，同时降低不必要的db性能损耗，我们对不同商品表实例做了redis的key区分（canal可以拿到表实例），这样在做dump时依次取不同实例的id，批量查询商品时就能保证db查询只会查询一个表实例。</p></blockquote><h2 id="热数据实时同步"><a href="#热数据实时同步" class="headerlink" title="热数据实时同步"></a>热数据实时同步</h2><p>当数据库中数据发生变更时，需要同步最新数据至es。可以通过canal监听表变更（Insert、Update、Delete）对文档做更新。</p><h3 id="同步所有"><a href="#同步所有" class="headerlink" title="同步所有"></a>同步所有</h3><p>初期考虑实现简单，当监听的表发生变更时，根据变更的数据取到对应的商品id（如商品表变更取id，服务商品表变更取该服务商品对应的商品id），然后调用同步方法（代码复用，全量同步时使用的方法）。这种方法也是简单粗暴，不易出错，但有如下问题：</p><ul><li>有些不必要更新的信息也通过RPC调用去获取了，产生了不必要的调用，且增加了增量更新的耗时，从而降低了索引数据的实时性。</li><li>当表变更数据量大时，由于RPC的调用耗时，更容易产生消息堆积，从而进一步降低了索引的实时性，且会增加调用的接口应用的压力。</li><li>当与商品表有一对多关系的数据发生更新时，那么需要对该数据关联的多个商品做同步，这种数据就很难做到实时更新。如：假设一个协议下有m个商品，同步一个商品需要调用n个RPC接口组装数据，那么当这个协议信息发生变更时，需要调用m*n次RPC接口组装数据；而一个协议下可能有高达几万的商品，通过这种方式去实时更新商品的协议信息几乎不可能（单条消息消费时间长）。</li></ul><h3 id="按需同步"><a href="#按需同步" class="headerlink" title="按需同步"></a>按需同步</h3><p>对于变更的数据，其实只需要同步es中的部分数据即可。如上所举例子，某个协议发生了变更，只需要更新该协议下商品索引中的的协议信息，使用es的<strong>updateByQuery</strong>即可（类似sql的update语句：update items set protocol_info = x where protocol_id = y）。这种方案有如下优点：</p><ul><li>canal消息中可以拿到更新的字段，对于es中不关心的字段的变更可以不做处理。</li><li>由于canal消息中可以拿到更新后的字段，在更新es时不需要再通过RPC调用去获取数据（某些场景下还是需要通过rpc调用获取数据）。</li></ul><p>但这种方案也有一些缺点：</p><ul><li>代码编写时需要关心es中的字段和数据库的字段关系。</li><li>新增字段需要更改增量更新的代码，开发过程中可能疏漏造成某些字段更新不及时。</li></ul><h2 id="冷数据同步"><a href="#冷数据同步" class="headerlink" title="冷数据同步"></a>冷数据同步</h2><p>商品索引中存在一些实时性不高（接受T+1的延迟）的信息。如：采购目录、仓库、配送地等。这类信息需要在每天非业务时间（00:00 ~ 07:00）同步一遍（同步需要调用大量rpc接口，为了不影响正常业务，需要在非业务时间段执行）。</p><h3 id="同步所有信息"><a href="#同步所有信息" class="headerlink" title="同步所有信息"></a>同步所有信息</h3><p>每天进行一次全量同步，组装所有数据更新至索引。这种方式<strong>简单粗暴</strong>，且能够<strong>为增量同步做兜底</strong>（某些异常情况下增量同步可能会失败）。但同时也带来其它问题：</p><ul><li>全量同步需要大量调用接口，导致应用和数据库在全量同步期间相关接口qps飙升、db实例cpu使用率飙升（使用率存在峰值，需要消峰），存在隐患。</li><li>索引数和商品数量不断增长，已经不能保证在非业务时间内对所有索引做完一次全量同步。</li><li>每日依赖一个如此<strong>重</strong>的任务让人感觉非常不踏实。</li></ul><h3 id="只同步冷数据"><a href="#只同步冷数据" class="headerlink" title="只同步冷数据"></a>只同步冷数据</h3><p>只针对冷数据做同步，有如下优点：</p><ul><li>大大减少rpc接口调用，缓解了应用和db的压力，降低风险。</li></ul><p>但这种方案不能为增量同步做兜底了。因此需要保证<strong>热数据实时同步</strong>能够稳定。</p><p>为了保证热数据能够实时同步稳定，我们做了以下处理：</p><ul><li>同步失败告警通知。若同步失败，第一时间通知到相关人员进行处理（关键字告警）。</li><li>同步失败重试。若同步失败，对失败的消息进行重试。大部分情况下（目前没有遇到其它情况），同步失败往往是某些应用突然宕机，但都能在可接受时间内恢复。恢复成功后消息重试即可。</li></ul><h3 id="只同步有更新的冷数据（todo，感谢-白杨-提供方案）"><a href="#只同步有更新的冷数据（todo，感谢-白杨-提供方案）" class="headerlink" title="只同步有更新的冷数据（todo，感谢 @白杨 提供方案）"></a>只同步有更新的冷数据（todo，感谢 @白杨 提供方案）</h3><p>也不是所有的冷数据需要同步。一般情况下，冷数据更新频率比较低，可以考虑只针对当日更新的冷数据做更新（假定目前的数据是最新）。具体方案如下：</p><ol><li>记录冷数据表当日更新记录（可以使用canal监听，使用redis记录）</li><li>根据更新记录，从es中搜索出需要更新的文档，只更新这些文档对应的冷数据</li></ol><p>例如，采购目录更新频率很低，商品通过区划和类目获取采购目录。当采购目录发生变更时，记录对应的区划和类目。更新采购目录时，通过发生了变更的区划和类目搜索出对应的商品，再对这些商品做更新即可。目前每天需要更新600w+商品的采购目录信息，使用这种方案可以大大减少接口调用。</p><h2 id="Canal消费者隔离"><a href="#Canal消费者隔离" class="headerlink" title="Canal消费者隔离"></a>Canal消费者隔离</h2><p>所有canal消息均发向同一topic，根据tag区分（库名+表名，db_name.table_name）。</p><h3 id="共用消费者"><a href="#共用消费者" class="headerlink" title="共用消费者"></a>共用消费者</h3><p>一个索引关心的多张表使用同一个消费者（订阅多个tag），消费者通过tag来区分表做不同操作。这种做法会可能会造成实时性要求不那么高的数据更新阻塞了实时性要求高的数据更新。如：一个商品索引的增量更新同时订阅了商品表和服务商品表（使用同一个消费者，商品信息的实时性高于服务商品信息）。当服务商品表发生大量插入时（供应商批量设置服务商品，最多高达10w+），会导致消息堆积。此时若商品表发生变更，商品信息的更新会滞后。</p><h3 id="隔离消费者"><a href="#隔离消费者" class="headerlink" title="隔离消费者"></a>隔离消费者</h3><p>根据场景使用不同消费者消费不同表的canal消息，不同表消息互不影响。同时，可以根据不同数据的实时性要求对不同消费者设置不同线程数，增加灵活性。</p><h2 id="任务类型"><a href="#任务类型" class="headerlink" title="任务类型"></a>任务类型</h2><h3 id="Spring-Scheduled-Job"><a href="#Spring-Scheduled-Job" class="headerlink" title="Spring Scheduled Job"></a>Spring Scheduled Job</h3><p>直接在方法上添加@Scheduled注解即可设置定时任务。这种方案实现简单，但不能随时调整触发时间，也不支持主动触发和关闭。</p><h3 id="Elastic-Job"><a href="#Elastic-Job" class="headerlink" title="Elastic Job"></a>Elastic Job</h3><p>通过elastic job控制台可以很方便地调整触发时间，也能主动触发和关闭。</p><h2 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h2><p>See you later…</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Apr 02 2019 15:28:57 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近对商品es同步应用（item-dump）做了些优化，感觉已经到了比较稳定成熟的阶段（啪啪），决定对整个商品es同步方案历程做个总结，希望能对其它同学在做es同步上提供参考。&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://thare.cn/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="https://thare.cn/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch DSL快速上手指南</title>
    <link href="https://thare.cn/posts/41633c75.html"/>
    <id>https://thare.cn/posts/41633c75.html</id>
    <published>2019-03-22T14:07:47.000Z</published>
    <updated>2019-04-02T07:28:06.737Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Apr 02 2019 15:29:15 GMT+0800 (China Standard Time) --><p>本文整理常用的Elasticsearch dsl，旨在帮助初学者能够快速构造dsl。如果想精通，还是阅读<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>为佳。</p><a id="more"></a><h2 id="如何搜索"><a href="#如何搜索" class="headerlink" title="如何搜索"></a>如何搜索</h2><p>向ES发送rest请求即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -XPOST http://ip:port?indexName/_search -d "json格式的dsl"</span><br></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>先介绍几种复合查询类型（需要包在bool中使用，详情看下方例子） <a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html" rel="external nofollow noopener noreferrer" target="_blank">官网传送门</a></p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>must</td><td>必须满足。包含在must内的条件都必须要满足，且会影响最后搜索得分。</td></tr><tr><td>must_not</td><td>必须不满足。包含在must_not内的条件都不应该满足，不会影响最后搜索得分。</td></tr><tr><td>filter</td><td>过滤。和must很像，但有两个区别<br>1. 不会影响搜索得分，速度较must更快<br>2.在ES内会有缓存，加快下次同样条件的查询</td></tr><tr><td>should</td><td>在should内的条件之间是或关系。</td></tr></tbody></table><p>再介绍几种常用的搜索类型 <a href="https://kapeli.com/dash_share?docset_file=ElasticSearch&amp;docset_name=ElasticSearch&amp;path=www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html&amp;platform=elasticsearch&amp;repo=Main&amp;source=www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html&amp;version=6.6.2" rel="external nofollow noopener noreferrer" target="_blank">官网传送门</a></p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>term</td><td>类似sql中的=</td></tr><tr><td>terms</td><td>类似sql中的in</td></tr><tr><td>match</td><td>分词匹配，一般嵌套在must内使用。<br>字段类型为text</td></tr><tr><td>match_phrase</td><td>短语匹配，一般嵌套在must内使用。</td></tr><tr><td>range</td><td>范围匹配</td></tr><tr><td>exists</td><td>存在</td></tr><tr><td>wildcard</td><td>模糊查询（禁止在程序中使用）</td></tr></tbody></table><p>下面通过一段dsl来理解</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"手机"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"must_not"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"status"</span>: <span class="number">-3</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"level"</span>: <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"price"</span>: &#123;</span><br><span class="line">              "from": 100, //下边界为100</span><br><span class="line">              "to": null, // 无上边界</span><br><span class="line">              "include_lower": true, // 包含下边界</span><br><span class="line">              "include_upper": false // 包含上边界</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      "should": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"brandId"</span>: <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"brandId"</span>: <span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段dsl的含义是</p><ol><li><p>name能匹配上”手机”</p></li><li><p>status不为-3且level不为1</p></li><li><p>价格大于等于100</p></li><li><p>brandId没有限制。很奇怪对不对？看看官方解释</p><blockquote><p>If the <code>bool</code> query is in a <a href="query-filter-context.html">query context</a> and has a <code>must</code> or <code>filter</code> clause then a document will match the <code>bool</code> query even if none of the <code>should</code> queries match. In this case these clauses are only used to influence the score.</p></blockquote><p>意思是：如果一个should同时和must或filter存在同一级，则搜索出来的文档可以不满足should中的条件，should中的条件仅仅会影响搜索得分。</p><p>因此，在这种情况下，<strong>brandId为1或2的结果搜索得分会更高</strong>。</p><p>如果想达到<strong>或</strong>关系要怎么做呢？有两种办法：</p><ol><li><p>同级查询类型中没有must或filter</p></li><li><p>将should包在filter内，例</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "filter":[</span><br><span class="line">    &#123;</span><br><span class="line">      "bool":&#123; // 记得包在bool中</span><br><span class="line">        "should":[</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"term"</span>: &#123;</span><br><span class="line">              <span class="attr">"brandId"</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"term"</span>: &#123;</span><br><span class="line">              <span class="attr">"brandId"</span>: <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="搜索属性"><a href="#搜索属性" class="headerlink" title="搜索属性"></a>搜索属性</h2><p>几种常用搜索属性 <a href="https://kapeli.com/dash_share?docset_file=ElasticSearch&amp;docset_name=ElasticSearch&amp;path=www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html&amp;platform=elasticsearch&amp;repo=Main&amp;source=www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html&amp;version=6.6.2" rel="external nofollow noopener noreferrer" target="_blank">官网传送门</a></p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>from</td><td>从第几条结果开始</td></tr><tr><td>size</td><td>返回多少条结果</td></tr><tr><td>_source</td><td>控制返回的字段</td></tr><tr><td>sort</td><td>排序方式，默认按搜索得分倒序排序</td></tr></tbody></table><p>看个例子</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"from"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: [<span class="string">"id"</span>, <span class="string">"name"</span>],</span><br><span class="line">  <span class="attr">"sort"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"updatedAt"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"asc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示</p><ol><li>从第10条记录开始，返回20条记录</li><li>只返回id和name两个字段</li><li>先按更新时间倒序，再按id升序排序</li></ol><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>几种常用聚合类型 <a href="https://kapeli.com/dash_share?docset_file=ElasticSearch&amp;docset_name=ElasticSearch&amp;path=www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html&amp;platform=elasticsearch&amp;repo=Main&amp;source=www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html&amp;version=6.6.2" rel="external nofollow noopener noreferrer" target="_blank">官网传送门</a></p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>terms</td><td>类似group by</td></tr><tr><td>cardinality</td><td>类似count(distinct)</td></tr><tr><td>extended_stats</td><td>计算count、sum、min、max等</td></tr></tbody></table><p>看个例子</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "aggs":&#123; //也可写为aggregations</span><br><span class="line">    "agg1":&#123;</span><br><span class="line">      "terms":&#123;</span><br><span class="line">        "field": "shopId"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "agg2":&#123;</span><br><span class="line">      "cardinality":&#123;</span><br><span class="line">        "field": "status"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "agg3":&#123;</span><br><span class="line">      "extended_stats":&#123;</span><br><span class="line">        "field": "price"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些聚合的含义是</p><ol><li>agg1：对shopId做group by</li><li>agg2：统计共有多少种status</li><li>agg3：查看价格的多种统计结果</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>看个比较完整的dsl</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"from"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: [</span><br><span class="line">    <span class="string">"id"</span>,</span><br><span class="line">    <span class="string">"name"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"updatedAt"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"asc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"手机"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"must_not"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"status"</span>: <span class="number">-3</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"level"</span>: <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"price"</span>: &#123;</span><br><span class="line">              <span class="attr">"from"</span>: <span class="number">100</span>,</span><br><span class="line">              <span class="attr">"to"</span>: <span class="literal">null</span>,</span><br><span class="line">              <span class="attr">"include_lower"</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">"include_upper"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"brandId"</span>: <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"brandId"</span>: <span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"agg1"</span>: &#123;</span><br><span class="line">      <span class="attr">"terms"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"shopId"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"agg2"</span>: &#123;</span><br><span class="line">      <span class="attr">"cardinality"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"status"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"agg3"</span>: &#123;</span><br><span class="line">      <span class="attr">"extended_stats"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Apr 02 2019 15:29:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本文整理常用的Elasticsearch dsl，旨在帮助初学者能够快速构造dsl。如果想精通，还是阅读&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;为佳。&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://thare.cn/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="https://thare.cn/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>使用Elasticsearch Scroll实现索引迁移工具</title>
    <link href="https://thare.cn/posts/21fbc3c7.html"/>
    <id>https://thare.cn/posts/21fbc3c7.html</id>
    <published>2018-10-11T08:22:43.000Z</published>
    <updated>2019-04-02T07:28:33.460Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Apr 02 2019 15:28:37 GMT+0800 (China Standard Time) --><p>最近需要在预发环境测试分词词库，但苦于没有预发环境机器的权限，不能随时改es的配置，也不想麻烦运维。虽然有开发环境的机器权限，但开发环境的索引数据量少，且数据不够优雅，不能很好地反映实际使用效果。所以，需要把预发环境的索引同步到开发环境。安全原因，开发环境和预发环境网络是隔离的，只能通过本地起服务来同步。</p><a id="more"></a><p>环境信息：</p><ul><li>索引量：100w</li><li>索引大小：1.5G</li><li>ES版本：6.2.3</li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>首先考虑的是使用es的scroll API来获取全部数据，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>是这样介绍的：</p><blockquote><p>While a <code>search</code> request returns a single “page” of results, the <code>scroll</code> API can be used to retrieve large numbers of results (or even all results) from a single search request, in much the same way as you would use a cursor on a traditional database.</p><p>Scrolling is not intended for real time user requests, but rather for processing large amounts of data, e.g. in order to reindex the contents of one index into a new index with a different configuration.</p></blockquote><p>即scroll可以获取大量结果（search的窗口大小只有10000），甚至是全部。但它不是为了实时请求（准实时）而生，而是为了处理大量的数据，例如为了修改索引配置而重建索引。所以这里使用scroll来迁移索引是再合适不过了。</p><p><strong><em>注意：scroll获取的数据是第一个scroll请求发起时的快照，从那刻以后索引发生的变更都不会影响scroll的结果。也就是说，如果整个scroll过程有1个小时，那么最后获取到的数据是1个小时前的快照。所以，对于有实时性要求的场景需要考虑通过其它手段来保证数据一致性。</em></strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>先看看如何使用scroll。</p><p>首先需要先发一个search请求，并指定scroll值（下面会讲）和其他搜索参数（如size、query等，只需第一次指定，后续请求都会沿用）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /item/_search?scroll=10s</span><br><span class="line">&#123;</span><br><span class="line">    "size": 500,</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "term" : &#123;</span><br><span class="line">            "status" : "1"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个请求除了返回基本的搜索结果外，还会有一个<code>_scroll_id</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_scroll_id"</span>: <span class="string">"DnF1ZXJ5VGhlbkZldGNoldG56LVJrdUtOVGtHQU1h"</span>,</span><br><span class="line">    <span class="attr">"took"</span>: <span class="number">5</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>_scroll_id</code>需要传入下次scroll请求中（类似游标），同时也需要指定scroll的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST  /_search/scroll </span><br><span class="line">&#123;</span><br><span class="line">    "scroll" : "10s", </span><br><span class="line">    "scroll_id" : "JLSGPOTWNTLKNG3SAGLKGKLJ8ASGLKMKSAGLSAMGSNA13KMFGKLNLKASNGCDSD==" </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此不断请求，直到返回的hits为空，就取到了满足搜索条件的所有数据了。</p><p><strong><em>注意：后续scroll请求不需要指定index。</em></strong></p><p>那么这个scroll参数是什么意思呢？<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html#scroll-search-context" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>如下</p><blockquote><p>The <code>scroll</code> parameter (passed to the <code>search</code> request and to every <code>scroll</code> request) tells Elasticsearch how long it should keep the search context alive. Its value (e.g. <code>1m</code>, see <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#time-units" rel="external nofollow noopener noreferrer" target="_blank">Time units</a>) does not need to be long enough to process all data — it just needs to be long enough to process the previous batch of results. Each <code>scroll</code> request (with the <code>scroll</code> parameter) sets a new expiry time.</p></blockquote><p>scroll参数用来告诉es需要将搜索上下文保持多久，这个时间<strong>不需要</strong>是你处理全部数据的时间，能保证处理完一批数据就行。例如，某次请求拿到了一批数据，只要在这段时间内处理完这批数据并能发起下一个请求就可以了。</p><p><strong><em>注意：scroll值不是越大越好。因为通常情况下，小的segment会合并成大的segment，同时小的segment会被删除。但在scroll的搜索上下文保持时间段内，小的segment不会被删除，而是被用来返回第一个搜索请求时刻的快照，这样会消耗更多的文件句柄。所以把scroll值设置成稍微比处理数据的时间多几秒就好。</em></strong></p><p>当然，如果不同批次的数据处理没有依赖关系的话，也可以通过多线程来处理数据，这样scroll参数可以设置小一点。</p><p>如果使用过期的_scroll_id将会得到如下报错</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"search_context_missing_exception"</span>,</span><br><span class="line"><span class="attr">"reason"</span>: <span class="string">"No search context found for id [xxx]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在scroll请求完后也可以手动清除搜索上下文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DELETE /_search/scroll</span><br><span class="line">&#123;</span><br><span class="line">    "scroll_id" : [</span><br><span class="line">      "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==",</span><br><span class="line">      "AAAAAAAFFmtSWWRRWUJrU2o2ZExpSGJCVmQAABBZrUllkUVlCa1NqNmRMaUhiQlZkMWFB"</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除所有<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /_search/scroll/_all</span><br></pre></td></tr></table></figure><p></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>scroll会用了，那下面就来实现吧。</p><p>基本流程：</p><ol><li>获取需要迁移的索引mapping</li><li>在新的es集群创建索引并设置mapping</li><li>通过scroll不断获取数据并写入新索引，直到scroll获取的数据为空</li></ol><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p><a href="https://github.com/Thare-Lam/elasticsearch-migration" rel="external nofollow noopener noreferrer" target="_blank">elasticsearch-migration</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Apr 02 2019 15:28:37 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近需要在预发环境测试分词词库，但苦于没有预发环境机器的权限，不能随时改es的配置，也不想麻烦运维。虽然有开发环境的机器权限，但开发环境的索引数据量少，且数据不够优雅，不能很好地反映实际使用效果。所以，需要把预发环境的索引同步到开发环境。安全原因，开发环境和预发环境网络是隔离的，只能通过本地起服务来同步。&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://thare.cn/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="https://thare.cn/tags/Elasticsearch/"/>
    
      <category term="索引迁移" scheme="https://thare.cn/tags/%E7%B4%A2%E5%BC%95%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch性能调优之设置refresh_interval实战</title>
    <link href="https://thare.cn/posts/c358565.html"/>
    <id>https://thare.cn/posts/c358565.html</id>
    <published>2018-09-28T07:36:51.000Z</published>
    <updated>2019-04-02T07:28:16.479Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Apr 02 2019 15:28:21 GMT+0800 (China Standard Time) --><p>接手搜索几个月了，把公司的商品搜索从业务代码剥离成独立应用，再不断调整优化（代码结构），目前暂时趋于稳定（搜索中心化和产品化还有很长一段路要走），也能够迅速响应上层业务方的需求。自己也由一个搜索小白到了小试牛刀的阶段。项目中也还有很多可以改进的地方，自己对ES的深度和广度也有待加强。</p><a id="more"></a><p>先贴上环境信息</p><ul><li>业务背景：商品</li><li>ES版本：6.2.3</li><li>集群配置：5台8核32G SSD</li><li>系统信息：CentOS 7.2 64位</li><li>索引信息：1100w个doc，5个分片，1个副本，约20G（不含副本）</li></ul><p>搜索应用的rt表现如下（qps约20）</p><p><img src="https://coding.net/u/Thare-Lam/p/blog/git/raw/master/asserts/img/0x02/before.jpg" alt="before"></p><p>可以看到，请求主要分布在400ms以内，且有一条明显的100ms分界线。</p><p>之前一直百思不得其解，直到某天看了@跳跳爸的Abc公众号的 <a href="https://mp.weixin.qq.com/s/NngpCYqPeTqXfslWC4opOQ" rel="external nofollow noopener noreferrer" target="_blank">中小规模搜索引擎（ElasticSearch）典型应用场景及性能优化（三）</a>才恍然大悟：</p><blockquote><p>索引配置比较灵活，粒度也比较细，当我们查询索引时其实都是查询某个时间的一个快照数据，只有index searcher重载一次索引文件，这期间（两次reopen index searcher之间）对索引进行的操作才会可见，这段时间也叫做刷新时间（refresh_interval）</p><p>需要注意的是重载索引文件（reopen index searcher）的开销很大，所以一般搜索引擎都是提供近实时的查询服务，以减少重载索引文件的次数，降低系统负载，有个案例：曾经将一个索引的刷新时间从1s调整到5s，整个搜索响应时间从200ms降低到20ms以内，效果可见一斑。</p></blockquote><p><strong><em>高于100ms的请求应该是在es刷新时处理的，所以导致rt高。想象一下，每秒都要对1100w的索引重新刷新，这得多消耗性能。</em></strong></p><p>于是，尝试修改了该索引的refresh_interval为30s（商品搜索实时性没那么高）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">put /&#123;index&#125;/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"index"</span>: &#123;</span><br><span class="line">        <span class="attr">"refresh_interval"</span>: <span class="string">"30s"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果十分明显：</p><p><img src="https://coding.net/u/Thare-Lam/p/blog/git/raw/master/asserts/img/0x02/compare.jpg" alt="compare"></p><p>可以看到，在16:05:30时刻将refresh_interval改成了30s，搜索应用的rt瞬间就下降了。并且可以看到，大概每隔30s会出现一两个请求rt较高的情况，这时候就是es重载了索引文件，导致请求变慢。</p><p>这是调整后的日常rt，效果较之前已经好很多了，基本都在100ms以内</p><p><img src="https://coding.net/u/Thare-Lam/p/blog/git/raw/master/asserts/img/0x02/after.jpg" alt="after"></p><p>不过还需继续努力，争取rt在50ms，并想办法消除refresh时的高rt。</p><p>总结一下：</p><ul><li>ES的查询是近实时的（需要做好至少延迟1S的打算），实时性高的场景不适用；</li><li>对于搜索结果实时性不高的场景（如上），可以适当增加refresh_internal，效果真的可见一斑。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Apr 02 2019 15:28:21 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;接手搜索几个月了，把公司的商品搜索从业务代码剥离成独立应用，再不断调整优化（代码结构），目前暂时趋于稳定（搜索中心化和产品化还有很长一段路要走），也能够迅速响应上层业务方的需求。自己也由一个搜索小白到了小试牛刀的阶段。项目中也还有很多可以改进的地方，自己对ES的深度和广度也有待加强。&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://thare.cn/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="https://thare.cn/tags/Elasticsearch/"/>
    
      <category term="性能调优" scheme="https://thare.cn/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Initialization</title>
    <link href="https://thare.cn/posts/8b7d4dee.html"/>
    <id>https://thare.cn/posts/8b7d4dee.html</id>
    <published>2018-09-27T13:07:52.000Z</published>
    <updated>2019-04-02T07:28:26.368Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Apr 02 2019 15:28:31 GMT+0800 (China Standard Time) --><p>果然是懒癌患者，不过应该还没到晚期，还有得治。</p><a id="more"></a><p>从大学起到研究生再到工作，中间多次下决心坚持写Blog，但最后往往都不了了之，其中最长坚持到一段时间应该是研究生期间了吧（<a href="https://blog.csdn.net/thare_lam" rel="external nofollow noopener noreferrer" target="_blank">献丑了</a>）。</p><p>当然也是知道对自己有帮助的，因为在写的过程中会总结思考，争取把技术和过程尽可能清楚地描述出来，这也是对自己做过和看过的一种总结。常言道，温故而知新。</p><p>所以，今天打算重新拾起，打算利用写Blog这个过程好好总结工作中遇到的问题，并把这些记录下来，给未来的自己留个纪念，同时也希望能够帮助到其他人。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Apr 02 2019 15:28:31 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;果然是懒癌患者，不过应该还没到晚期，还有得治。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://thare.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://thare.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
